use serde::{Deserialize, Serialize};
use validator::Validate;
use crate::auth::error::AuthError;
#[derive(Debug, Serialize, Deserialize, Validate)]
pub struct LoginRequest {
    #[validate(length(min = 1, max = 150))]
    pub username: String,
    #[validate(length(min = 1, max = 30))]
    pub password: String,
    pub remember_me: bool,
}

#[derive(Debug, Serialize, Deserialize, Validate)]
pub struct RegisterRequest {
    #[validate(length(min = 1, max = 30))]
    pub username: String,
    #[validate(email)]
    pub email: String,
    #[validate(length(min = 1, max = 30))]
    pub password: String,
}

pub struct RenewRequest {
    pub token: String,
}

/// # Token Response
#[derive(Debug, Serialize, Deserialize)]
pub struct TokenResponse {
    /// ## Long token
    /// The long token is stored in the local storage and in the database
    /// This token is used to authenticate the user and generate the short token
    /// The long_token is only present in the response when the user logs in or registers
    pub long_token: Option<String>,
    /// ## Short token
    /// The short token is stored also in the local storage but not in the database
    /// This token is used to authenticate the user in microservices, and it is valid for a short period of time
    /// The short token is generated by the long token, and it is signed with a secret key that is stored in the microservices,
    /// and it is used to verify the token
    pub short_token: String,
}


#[async_trait::async_trait]
pub trait AuthService: Send + Sync {
    async fn login(&self, login_request: LoginRequest) -> Result<TokenResponse, AuthError>;
    async fn register(&self, register_request: RegisterRequest) -> Result<TokenResponse, AuthError>;
    async fn renew(&self, renew_request: RenewRequest) -> Result<TokenResponse, AuthError>;
}
